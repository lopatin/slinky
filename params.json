{"name":"Slinky","body":"#Slinky \r\n\r\nSlinky helps you write rich web applications using compiled web\r\nlanguages like SASS, HAML and CoffeeScript. The slinky server\r\ntransparently compiles resources as they're requested, leaving you to\r\nworry about your code, not how to compile it. It will even proxy\r\nAJAX requests to a backend server so you can easily develop against\r\nREST APIs.\r\n\r\nOnce you're ready for production the slinky builder will compile all of\r\nyour sources and concatenate and minify your javascript and css,\r\nleaving you a directory that's ready to be pushed to your servers.\r\n\r\n## Quickstart\r\n\r\n```\r\n$ gem install slinky\r\n$ cd ~/my/awesome/project\r\n$ slinky start\r\n[hardcore web development action]\r\n$ slinky build\r\n$ scp -r build/ myserver.com/var/www/project\r\n````\r\n## But tell me more!\r\n\r\nSlinky currently supports three languages for compilation, SASS/SCSS,\r\nHAML and CoffeeScript, but it's simple to add support for others (and\r\nplease submit a pull request when you do!). Slinky also has a few\r\ntricks of its own for managing the complexity of modern web\r\ndevelopment.\r\n\r\n### Script & style management\r\n\r\nSlinky can manage all of your javascript and css files if you want it\r\nto, serving them up individually during development and concatenating\r\nand minifying them for production. To support this, Slinky recognizes\r\n`slinky_scripts` in your HTML/Haml files. For example, when Slinky\r\nsees this:\r\n\r\n```haml\r\n!!!5\r\n%html\r\n  %head\r\n    slinky_scripts\r\n    slinky_styles\r\n  %body\r\n    %h1 Hello, world!\r\n```\r\n\r\nit will compile the HAML to HTML and replace slinky_styles with the\r\nappropriate HTML.\r\n\r\n### Specifying order\r\n\r\nBut what if your scripts or styles depend on being included in the\r\npage in a particular order? For this, we need the `slinky_require`\r\ndirective.\r\n\r\nFor example, consider the case of two coffeescript files, A.coffee and\r\nB.coffee. A includes a class definition that B depends upon, so we\r\nwant to make sure that A comes before B in the concatenation order. We\r\ncan solve this simply using `slinky_require(script)`\r\n\r\nFile A.coffee:\r\n\r\n```coffeescript\r\nclass A\r\n  hello: (thing) -> \"Hello, \" + thing\r\n```\r\n\r\nFile B.coffee:\r\n\r\n```coffeescript\r\nslinky_require(\"A.coffee\")\r\nalert (new A).hello(\"world\")\r\n```\r\nWe can also do this in CSS/SASS/SCSS:\r\n\r\n```sass\r\n/* slinky_require(\"reset.css\")\r\na\r\n  color: red\r\n```\r\n\r\n### Specifing dependencies\r\n\r\nAs HAML and SASS scripts can include external content as part of their\r\nbuild process, it may be that you would like to specify that files are\r\nto be recompiled whenever other files change. For example, you may use\r\nmustache templates defined each in their own file, but have set up\r\nyour HAML file to include them all into the HTML. Thus when one of the\r\nmustache files changes, you would like the HAML file to be recompiled\r\nso that the templates can be updated also.\r\n\r\nThese relationships are specified as \"dependencies,\" and like requirements\r\nthey are incdicated through a special `slinky_depends(\"file\")` directive in \r\nyour source files. For our template example, the index.haml files might look \r\nlike this:\r\n\r\n```haml\r\nslinky_depends(\"scripts/templates/*.mustache\")\r\n!!!5\r\n\r\n%html\r\n  %head\r\n    %title My App\r\n    slinky_styles\r\n    slinky_scripts\r\n    - Dir.glob(\"./scripts/templates/*.mustache\") do |f|\r\n      - name = File.basename(f).split(\".\")[0..-2].join(\".\")\r\n      %script{:id => name, :type => \"text/x-handlebars-template\"}= File.read(f)\r\n  %body\r\n```\r\n\r\n## Configuration\r\n\r\nSlinky can optionally be configured using a yaml file. By default, it\r\nlooks for a file called `slinky.yaml` in the source directory, but you\r\ncan also supply a file name on the command line using `-c`.\r\n\r\nThere are currently two directives supported:\r\n\r\n### Proxies\r\n\r\nSlinky has a built-in proxy server which lets you test ajax requests\r\nwith your actual backend servers. To set it up, your slinky.yaml file\r\nwill look something like this:\r\n\r\n```yaml\r\nproxy:\r\n  \"/login\": \"http://127.0.0.1:4567/login\"\r\n  \"/search\":\r\n    to: \"http://127.0.0.1:4567/search\"\r\n    lag: 2000\r\n```\r\n\r\nWhat does this mean? We introduce the list of proxy rules using the\r\n`proxy` key. Each rule is a key value pair. The key is a url prefix to\r\nmatch against. The first rule is equivalent to the regular expression\r\n`/\\/login.*/`, and will match paths like `/login/user` and\r\n`/login/path/to/file.html`. The value is either a url to pass the\r\nrequest on to or a hash containing configuration (one of which must be\r\na `to` field). Currently a `lag` field is also supported. This delays\r\nthe request by the specified number of milliseconds in order to\r\nsimulate the latency associated with remote servers.\r\n\r\nAn example: we have some javascript code which makes an AJAX GET\r\nrequest to `/search/widgets?q=foo`. When slinky gets the request it\r\nwill see that it has a matching proxy rule, rewrite the request\r\nappropriately (changing paths and hosts) and send it on to the backend\r\nserver (in this case, 127.0.0.1:4567). Once it gets a response it will\r\nwait until 2 seconds has elapsed since slinky itself received the\r\nrequest and then send on the response back to the browser.\r\n\r\nThis is very convenient for developing rich web clients locally. For\r\nexample, you may have some code that shows a loading indicator while\r\nan AJAX request is outstanding. However, when run locally the request\r\nreturns so quickly that you can't even see the loading indicator. By\r\nadding in a lag this problem is remedied.\r\n\r\n###  Ignores\r\n\r\nBy default slinky will include every javascript and css file it finds\r\ninto the combined scripts.js and styles.css files. However, it may be\r\nthat for some reason you want to keep some files separate and handle\r\nthem manually. The ignore directive lets you do that, by telling the\r\nsystem to skip over any files or directories listed. For example:\r\n\r\n```yaml\r\nignore:\r\n  - script/vendor\r\n  - css/reset.css\r\n```\r\n\r\nThis will causes everything in the script/vendor directory to be\r\nignored by slinky, as well as the reset.css file.\r\n","tagline":"Compiling static file + proxy server for rich client apps","google":"UA-78795-10","note":"Don't delete this file! It's used internally to help with page regeneration."}